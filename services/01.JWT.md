# JWT

## 1、JWT概念

JSON Web Token (JWT) 是一种开放标准 (RFC 7519)，它定义了一种紧凑且独立的用于在各方之间以 JSON 对象的形式安全地传输信息的方式。

JWT 可以使用 HMAC 算法或使用 RSA 或 ECDSA 的公钥/私钥对进行签名。

## 2、JWT的组成

在其紧凑形式中，JWT 由用点 ( . ) 分隔的三个部分组成，它们是：

* Header 标头
* Payload 有效载荷
* Signature 签名

```json
xxxxx.yyyyy.zzzzz
```

### 2.1、Header

通常由两部分组成：令牌的类型（JWT）和所使用的签名算法（例如 HMAC SHA256 或 RSA）。对该 JSON 进行 Base64Url 编码以形成 JWT 的第一部分。

```json
{
  "alg": "HS256", // Algorithm 的简写，加密签名算法
  "typ": "JWT" // type 的简写，令牌类型，也就是JWT
}
```

Header部分常用部分的声明：


| key  | name                 | 说明                                                                                                         |
| ---- | -------------------- | ------------------------------------------------------------------------------------------------------------ |
| typ  | 令牌类型             | 如果存在，则必须将其设置为已注册的 IANA 媒体类型。                                                           |
| cty  | 内容类型             | 如果使用嵌套签名或加密，建议将其设置为 ;否则，请省略此字段。                                                 |
| alg  | 消息身份验证代码算法 | 发行者可以自由设置算法来验证令牌上的签名。但是，某些受支持的算法不安全。                                     |
| kid  | 密钥标识             | 指示客户端用于生成令牌签名的密钥的提示。服务器将此值与文件上的密钥匹配，以验证签名是否有效以及令牌是否真实。 |
| x5c  | x.509 证书链         | RFC4945 格式的证书链，对应于用于生成令牌签名的私钥。服务器将使用此信息来验证签名是否有效以及令牌是否真实。   |
| x5u  | x.509 证书链网址     | 服务器可在其中检索与用于生成令牌签名的私钥对应的证书链的 URL。服务器将检索并使用此信息来验证签名是否真实。   |
| crit | 危急                 | 服务器必须理解的标头列表，以便接受令牌为有效令牌                                                             |

签名算法一般使用HS256，JWT官网提供了12种的加密算法:

1. HS265
2. HS384
3. HS512
4. RS265
5. RS384
6. RS512
7. ES256
8. ES384
9. ES512
10. PS256
11. PS384
12. PS512

### 2.2、Payload

令牌的第二部分是有效负载，其中包含声明（JWT claims）。

声明是关于实体（通常是用户）和附加数据的声明。声明分为三种类型：注册声明、公共声明和私人声明。

* **注册声明**（[**Registered claims**](https://tools.ietf.org/html/rfc7519#section-4.1)）：这些是一组预定义的声明，不是强制性的，而是推荐的，以提供一组有用的、可互操作的声明。其中一些是：iss（发行者）、exp（到期时间）、sub（主题）、aud（受众）等。
* **公共声明**（[**Public claims**](https://tools.ietf.org/html/rfc7519#section-4.2)）：这些可以由使用 JWT 的人随意定义。但为了避免冲突，它们应该在 IANA JSON Web 令牌注册表（[IANA JSON Web Token Registry](https://www.iana.org/assignments/jwt/jwt.xhtml)）中定义，或者定义为包含防冲突命名空间的 URI。
* **私人声明**（[**Private claims**](https://tools.ietf.org/html/rfc7519#section-4.3)）：这些是为在同意使用它们的各方之间共享信息而创建的自定义声明，既不是注册声明也不是公开声明。

请注意，声明名称只有三个字符长，因为 JWT 旨在紧凑。

对 **Payload** 进行 Base64Url 编码以形成 JSON Web 令牌的第二部分。

以下是Payload的官方定义内容：


| key | name                | 说明                                                                                                                                                            |
| --- | ------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| iss | 发送者              | 标识颁发 JWT 的发送主体。                                                                                                                                       |
| sub | 主题                | 标识 JWT 的主题。                                                                                                                                               |
| aud | 接收者              | 标识 JWT 所针对的接收者。每个在处理 JWT 的主体**都必须**使用受众声明中的值来标识自己。如果处理的主体在存在此声明时未将自己标识为声明中的值，则必须拒绝**JWT。** |
| exp | 到期时间            | 标识不得接受**JWT 进行处理**的过期时间。该值必须是日期类型，而且是1970-01-01 00：00：00Z 之后的日期秒。                                                         |
| nbf | jwt的开始处理的时间 | 标识 JWT 开始接受处理的时间。该值必须是日期。                                                                                                                   |
| iat | jwt发出的时间       | 标识 JWT 的发出的时间。该值必须是日期。                                                                                                                         |
| jti | jwt id              | 令牌的区分大小写的唯一标识符，即使在不同的颁发者之间也是如此。                                                                                                  |

```json
{
  "sub": "1234567890", // 注册声明
  "name": "John Doe", // 公开声明
  "admin": true // 公开声明
}
```

请注意，对于签名令牌虽然受到防止篡改的保护，但任何人都可以读取。

除非加密，否则请勿将秘密信息放入 JWT 的有效负载或标头元素中。

### 2.3、Signature

Signature 部分是对 Header 和 Payload 两部分的签名，作用是防止 JWT 被篡改。生成规则主要公式是：

```json
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)

Header中定义的签名算法(
    base64编码(header) + "." + base64编码(payload),
    secret
)
```

`secret`是存放在服务端加密使用到的盐。

签名用于验证消息在传输过程中没有发生更改，并且在使用私钥签名的令牌的情况下，它还可以验证 JWT 的发送者是否是其所说的人。

### 2.4、输出

输出是三个由点分隔的 Base64-URL 字符串，可以在 HTML 和 HTTP 环境中轻松传递，同时与基于 XML 的标准（例如 SAML）相比更加紧凑。


## 3、JWT如何工作

当用户使用其凭据成功登录时将返回 JSON Web Token。

为了防止引起安全问题，令牌的过期时间不应过长。

由于缺乏安全性，也不应该将包含敏感会话数据的JWT存储在浏览器存储中。

用户需要访问受保护的路由或资源时，用户代理应该发送 JWT，通常使用承载模式在授权标头中发送。标头的内容应如下所示：

```json
Authorization: Bearer <token>
```

服务器的受保护路由将检查 `Authorization` 标头中是否存在有效的 JWT，如果存在，则将允许用户访问受保护的资源。

如果 JWT 包含必要的数据，则可能会减少查询数据库以执行某些操作的需要。

如果通过 HTTP 标头发送 JWT 令牌，则应尽量防止它们变得太大。

因为某些服务器不接受超过 8 KB 的标头，所以如果在 JWT 令牌中嵌入太多信息可能就需要寻找替代解决方案，例如 Auth0 细粒度授权。

## 4、JWT的优缺点

**JWT 优点：**

1. `可扩展性好` 应用程序分布式部署的情况下，如果使用session机制，那就要要做多台机器的数据共享，通常可以存在数据库或者redis里面。而使用jwt不需要共享。
2. `jwt是无状态的` jwt不在服务端存储任何状态。RESTful API的原则之一是无状态，发出请求时，总会返回带有参数的响应，不会产生附加影响。用户的认证状态引入这种附加影响，这破坏了这一原则。另外jwt的载荷中可以存储一些常用信息，用于交换信息，有效地使用 JWT，可以降低服务器查询数据库的次数。

**JWT 缺点：**

1. `安全性` 由于jwt的payload是使用base64编码的，并没有加密，因此jwt中不能存储敏感数据。而session的信息是存在服务端的，相对来说更安全。
2. `一次性` 无状态是jwt的特点，但也导致了这个问题，jwt是一次性的。想修改里面的内容，就必须签发一个新的jwt。


资料来源： https://jwt.io/introduction
