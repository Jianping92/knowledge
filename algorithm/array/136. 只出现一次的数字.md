# 只出现一次的数字

地址：https://leetcode.cn/problems/single-number/description/?envType=problem-list-v2&envId=array


## 题目

给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

**示例 1 ：**

**输入：**nums = [2,2,1]

**输出：**1

**示例 2 ：**

**输入：**nums = [4,1,2,1,2]

**输出：**4

**示例 3 ：**

**输入：**nums = [1]

**输出：**1

**提示：**

* `1 <= nums.length <= 3 * 10<sup>4</sup>`
* `-3 * 10<sup>4</sup> <= nums[i] <= 3 * 10<sup>4</sup>`
* 除了某个元素只出现一次以外，其余每个元素均出现两次。


## 解题

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    // let res = 0;
    // for (let num of nums) {
    //     res ^= num;
    // }

    // return res;
    return nums.reduce((acc, num) => acc ^ num);
};
```


**解法思路**：

* 利用异或运算的三个核心特性：
  1. 归零律：`a ^ a = 0`
  2. 恒等律：`0 ^ a = a`
  3. 交换律/结合律：异或操作顺序不影响最终结果
* 通过遍历数组将所有元素异或，重复元素相互抵消，最终剩余的就是唯一出现一次的数字

**时间复杂度**：O(n)
**空间复杂度**：O(1)
**算法优势**：完全满足题目要求的线性时间复杂度和常量空间复杂度，且代码简洁优雅，充分体现位运算的高效特性。


## 异或运算

**异或计算（XOR）** 是一种**二进制位运算**，符号为 `^`，规则如下：

```javascript
// 按位比较，相同为0，不同为1
0 ^ 0 = 0
1 ^ 1 = 0
0 ^ 1 = 1
1 ^ 0 = 1
```

---

### 🌟 **在JavaScript中的实际应用**

#### 1️⃣ **抵消重复元素**

当数组中**所有重复元素都出现两次**时，异或运算能完美抵消它们：

```javascript
// 示例：nums = [4, 1, 2, 1, 2]
// 4 ^ 1 ^ 2 ^ 1 ^ 2 = 4
// 因为 1^1=0, 2^2=0, 最终只剩4
```

#### 2️⃣ **交换变量值**

无需临时变量即可交换两个变量的值：

```javascript
let a = 5, b = 3;
a ^= b; // a = 6 (5^3)
b ^= a; // b = 5 (3^6)
a ^= b; // a = 3 (6^5)
console.log(a, b); // 3, 5
```

#### 3️⃣ **生成掩码/校验**

常用于生成唯一标识或简单加密：

```javascript
const key = 0xDEADBEEF; // 加密密钥
const data = 0x12345678; 
const encrypted = data ^ key; // 加密
const decrypted = encrypted ^ key; // 解密
```

---

### 🔍 **为什么异或能解决“找唯一数”问题？**

#### 核心逻辑：

- **成对元素异或后归零** → `a ^ a = 0`
- **零与唯一数异或等于自身** → `0 ^ b = b`
- **异或满足交换律和结合律** → 运算顺序不影响结果

---

### 🚀 **性能优势**

```javascript
// 时间复杂度 O(n)，空间复杂度 O(1)
// 对比其他方法（如哈希表）的明显优势：
const findUnique = nums => nums.reduce((acc, num) => acc ^ num, 0);
```

通过位运算直接操作内存中的二进制位，这种底层操作速度极快，是处理大规模数据时的首选方案。
